# 32비트 보호모드로 전환

리얼 모드에서 보호모드로 전환하기 위해서는 6단계를 거쳐야 한다.

2단계는 보호모드 전환에 필요한 자료구조를 생성하는 단계이며, 4단계는 생성된 자료구조를 프로세서에 설정하는 단계이다. 반드시 필요한 자료구조는 **세그먼트 디스크립터**와 **GDT**이며 두 가지 자료구조는 보호모드로 전환하는 즉시 프로세서에 의해 참조되기 때문이다.

### 보호모드로 전환하는 6가지 단계

1. 세그먼트 디스크립터 생성

2. GDT 정보 생성

3. 프로세서에 GDT 정보 설정

4. CR0 컨트롤 레지스터 설정

5. jmp 명령으로 CS 세그먼트 셀렉터 변경과 보호모드로 전환                                                           **16비트 리얼모드**

   ---

6. 각종 세그먼트 셀렉터 및 스택 초기화                                                                                                 **32비트 보호모드**

### 세그먼트 디스크립터(Segment Descriptor) 생성

세그먼트 디스크립터는 세그먼테이션 기법에서 세그먼트의 정보를 나타내는 자료구조이다.

세그먼트는에 대한 정보를 나타내는 세그먼트 디스크립터는 크게 2가지로 나누어진다

* **코드 세그먼트 디스크립터**

  실행 가능한 코드가 포함된 세그먼트에 대한 정보를 나타내며, CS 세그먼트 셀렉터에 사용됨

* **데이터 세그먼트 디스크립터**

  데이터가 포함된 세그먼트에 대한 정보를 나타내며, CS 세그먼트 셀렉터를 제외한 나머지 셀렉터에 사용할 수 있음. ex) 스택 영역 또한 데이터를 읽고 쓰는 데이터 영역의 한 종류로 데이터 세그먼트 디스크립터를 사용

![Segment_Descriptor](.\image\Segment_Descriptor.PNG) 

↑ **세그먼트 디스크립터 구조와 각 필드 설명**

| **필드**      | **설명**                                                     |
| :------------ | ------------------------------------------------------------ |
| Base          | - 세그먼트의 시작 어드레스<br>- 32비트 크기이며, 0바이트 ~ 4GB까지 설정 가능 |
| Segment Limit | - 세그먼트의 크기<br>- 20비트 크기<br>- G필드 값으로 가중치가 곱해질 수 있음 |
| Type          | - 세그먼트의 타입<br>- 코드 또는 데이터 세그먼트로 설정가능  |
| S             | - 디스크립터의 타입<br>- 세그먼트 디스크립터: 1, 시스템 디스크립터:  0 |
| DPL           | - 해당 디스크립터를 사용에 필요한 권한을 의미<br>- 0(Highest) ~ 3(Lowest)의 범위를 가짐<br>- CPL, RPL과 조합되어 접근 권한을 제한 하는데 사용 |
| P             | - 현재 디스크립터가 유효한 디스크립터인지 표시<br>- 유효: 1, 유효하지 않음: 0 |
| AVL           | - OS가 임의의 용도로 사용할 수 있는 영역                     |
| L             | - IA-32e 모드에서 사용하는 필드로 32/64비트 코드 세그먼트를 의미<br>- 64비트: 1, 32비트: 0 |
| D/B           | - Default Operation Size를 의미<br>- 32비트용 세그먼트: 1, 16비트용 세그먼트: 0 |
| G             | - 세그먼트 크기 필드에 곱해질 가중치를 의미<br>- 1로 설정되면 4KB의 가중치를 곱하며, 0으로 설정되면 곱하지 않음 |

#### 세그먼트 타입 설정

코드 세그먼트와 데이터 세그먼트를 설정하려면 S 필드와 Type 필드를 조합해야 한다. 

두 세그먼트 모두 세그먼트 디스크립터이기 때문에 S 필드에는 1을 설정하며, 세그먼트 타입은 Type 필드에서 설정 한다. 

* 코드 세그먼트: 실행/읽기 타입 (0x0A)

* 데이터 세그먼트: 읽기/쓰기 타입 (0x02)

![Code_and_Data_Segment_Types](.\image\Code_and_Data_Segment_Types.PNG) 

↑ **세그먼트 타입 비트 설명**

#### OS 디스크립터 설정

* 커널 세그먼트 디스크립터는 4GB 전체 영역에 접근할 수 있어야 한다. 

  Base: 0, Segment Limit: 0xFFFF, G(가중치): 1

* 보호 모드는 32비트로 동작하므로 기본 오퍼랜드의 크기는 32비트여야 함

  D/B: 1, L: 0

* 권한 필드는 OS에서 핵심 부분을 보호하기 위해 꼭 사용해야 하지만 우리가 만들 OS에서는 권한 구분 x

  DPL: 0

* 유효한 디스크립터라는 것을 알려야 함 + 따로 임의에 별도의 값을 쓰지 않음

  P: 1, AVL: 0

##### 커널 코드 세그먼트와 데이터 세그먼트 디스크립터 생성 코드

```assembly
CODEDESCRIPTOR:
	dw 0xFFFF	; Limit [15:0]
	dw 0x0000	; Base [15:0]
	db 0x00		; Base [23:16]
	db 0x9A		; P=1, DPL=0, Code Segment, Execute/Read
	db 0xCF		; G=1, D=1, L=0, Limit[19:16]
	db 0x00		; Base [31:24]
	
DATADESCRIPTOR:
	dw 0xFFFF	; Limit [15:0]
	dw 0x0000	; Base [15:0]
	db 0x00		; Base [23:16]
	db 0x92		; P=1, DPL=0, Data Segment, Read/Write
	db 0xCF		; G=1, D=1, L=0, Limit[19:16]
	db 0x00		; Base [31:24]
```

 ### GDT(Global Descriptor Table) 정보 생성

* 디스크립터를 연속하여 모아놓은 집합으로 맨 앞에 널(NULL) 디스크립터를 추가해야 함

* 널 디스크립터는 프로세서에 의해 예약된 디스크립터로 모든 필드가 0이며 일반적으로 참조되지 않음

![Pseudo-Descriptor](.\image\Pseudo-Descriptor.PNG) 

↑ **GDTR**

GDT는 디스크립터의 집합이므로 프로세서에 시작 어드레스와 크기 정보를 로딩해야 한다. 

이것을 저장하는 자료구조는 **GDTR**이며 위와 같은 구조를 하고 있다.

![Global_and_Local_Descriptor_Tables](.\image\Global_and_Local_Descriptor_Tables.PNG) 

↑ **GDT ↔ LDT 스위칭**

디스크립터는 8바이트 크기로 GDTR의 크기 필드가 16비트라 최대 8,192개가 된다. 이는 여러 기타 디스크립터를 생성하다보면 공간이 부족할 수 있다. 그래서 x86 프로세서에서는 이 문제를 해결 하기 위해 LDT(Local Descriptor Table)를 제공한다. LDT도 마찬가지로 8,192개의 디스크립터를 저장 할 수 있다. (우리가 만들 OS에서는 사용 X)

##### GDTR 및 GDT 정보 생성 코드

```assembly
; GDTR 자료구조 정의
GDTR:
	dw GDTEND - GDT - 1			; 아래에 위치하는 GDT 테이블의 전체 크기
	dd ( GDT - $$ + 0x10000 )	; 아래에 위치하는 GDT 테이블의 시작 어드레스
	
; GDT 테이블 정의
GDT:
	; 널 디스크립터. 0으로 초기화 하여야 함
	NULLDescriptor:
		dw 0x0000
		dw 0x0000
		db 0x00
		db 0x00
		db 0x00
		db 0x00
		
	- 생략 -
	
	; 보호 모드 커널용 데이터 서그먼트 디스크립터
	DATADESCRIPTOR:
		dw 0xFFFF	; Limit [15:0]
		dw 0x0000	; Base [15:0]
		db 0x00		; Base [23:16]
		db 0x92		; P=1, DPL=0, Data Segment, Read/Write
		db 0xCF		; G=1, D=1, L=0, Limit [19:16]
		db 0x00		; Base [31:24]
GDTEND:
```

### 보호 모드로 전환

보호모드로 전환하려면 GDTR 설정, CR0 컨트롤 레지스터 설정, jmp 명령 수행 3단계만 수행하면 된다.

보호모드로 전환하는 과정과 전환 후 인터럽트 설정을 완료하기 전까지는 인터럽트가 발생하지 않게하는 것이 좋다. 인터럽트 설정이 완료되기 전에 인터럽트가 발생하면 프로세서는 인터럽트 처리 함수(핸들러)를 찾을 수 없어 예기치 못한 문제가 발생할 수 있다.

인터럽트 발생하지 않게 설정하는 어셈블리 명령어: cli

#### GDTR 설정

프로세서에서 GDT 정보를 설정하려면 lgdt 명령어를 사용한다.

```assembly
lgdt [ GDTR ]	; GDTR 자료구조를 프로세서에 설정하여 GDT 테이블을 로드
```

#### CR0 컨트롤 레지스터 설정

CR0 컨트롤 레지스터에는 보호모드 전환에 관련된 필드 외의 캐시(Cache), 페이징(Paging), 실수 연산 장치(FPU) 등과 관련된 필드가 포함되어 있다.

![CR0_Control_Register](.\image\CR0_Control_Register.PNG) 

↑ **CR0 컨트롤 레지스터 구조**

| 필드 | 설명                                                         |
| ---- | ------------------------------------------------------------ |
| PE   | - Protection Enable의 약자로 보호 모드 진입 여부를 설정<br />- 보호모드: 1, 리얼모드: 0 |
| MP   | - Monitor Coprocessor의 약자로 wait 또는 fwait 명령 실행 시 TS 필드 참고 여부 설정<br />- 1로 설정하면 wait 또는 fwait 명령 실행 시 TS 필드가 1이면 Device-not-available 예외가 발생하며, 0으로 설정하면 TS 필드의 값을 무시 함 |
| EM   | - Emulation의 약자로 프로세서에 FPU 내장되었는지 여부를 설정<br />- 1로 설정하면 FPU 관련 명령 실행 시 Device-not-available 또는 Invalid-opcode 예외가 발생하며, 0으로 설정하면 정상적으로 실행<br />- FPU가 없으면 실수 연산 명령을 소프트웨어적으로 처리할 목적으로 사용 |
| TS   | - Task Switched의 약자로 태스크가 전환되었음을 나타냄<br />- 1로 설정하면 FPU 관련 명령 실행 시 Device-not-available 예외가 발생하며, 0으로 설정하면 FPU 관련 명령을 정상적으로 실행<br />- EM 필드와 MP 필드와 조합하여 FPU의 상태를 저장하고 복구하는 용도로 사용 |
| ET   | - Extension Type의 약자로 1로 예약됨<br />- 과거 386, 486 프로세서에서 FPU를 지원한다는 것을 표시하는 용도로 사용 |
| NE   | - Numeric Error의 약자로 FPU 에러 처리 여부를 내부 인터럽트 또는  외부 인터럽트 중 선택<br>- 1로 설정하면 FPU 에러를 프로세서 내부의 예외로 연결하며, 0으로 설정하면 인터럽트로 연결함 |
| WP   | - Write Protect의 약자로서, 쓰기 금지 기능을 사용할지 여부를 설정<br />- 1로 설정하면 상위 권한(0~2)의 코드가 유저 권한(3)으로 설정된 읽기 전용 페이지에 쓸 수 없으며, 0으로 설정하면 페이지 속성에 관계없이 쓸 수 있음 |
| AM   | - Alignment Mask의 약자로 어드레스 정렬 검사 기능을 사용할지 여부를 설정<br />- 1로 설정하면 데이터나 어드레스가 특정 값의 배수에서 시작하는지 체크하며, 0으로 설정하면 체크하지 않음 |
| NW   | - Not Write-through의 약자로 캐시 정책 중 Write-through를 사용할지 여부를 설정<br />- 1로 설정하면 Write-back 정책을 사용하며, 0으로 설정하면 Write-through 정책을 사용 |
| CD   | - Cache Disable의 약자로 프로세서의 캐시를 사용할지 여부를 설정<br />- 1로 설정하면 캐시를 사용하지 않으며, 0으로 설정하면 캐시를 사용함 |
| PG   | - Paging의 약자로서, 페이징 기능을 사용할지 여부를 설정<br />- 1로 설정하면 페이징 기능을 사용하며, 0으로 설정하면 페이징 기능을 사용하지 않음 |

우리가 만드는 OS에서 보호모드는 IA-32e 모드를 위해 거쳐가는 임시모드에 불과하기 때문에 세그먼테이션 기능 외에 페이징, 캐시, 메모리 정렬검사 등은 사용하지 않는다.

```assembly
mov, eax, 0x4000003B	; PG=0, CD=1, NW=0, AM=0, WP=0, NE=1, ET=1, TS=1, EM=0, MP=1, PE=1
mov, cr0, eax			; CR0 컨트롤 레지스터에 위에서 저장한 플래그를 설정하여 보호 모드로 전환
```

#### 보호모드로 전환과 세그먼트 셀렉터 초기화

```assembly
; 커널 코드 세그먼트를 0x00 기준으로 하는 것으로 교체하고 EIP의 값을 0x00을 기준으로 재설정
; CS 세그먼트 셀렉터 : EIP
jmp dword 0x08: ( PROTECTEDMODE - $$ + 0x10000 )

[BITS 32]
PROTECTEDMODE:
	mov ax, 0x10	; 보호모드 커널용 데이터 세그먼트 디스크립터 저장
	mov ds, ax		; DS 세그먼트 셀렉터에 설정
	mov es, ax		; ES 세그먼트 셀렉터에 설정
	mov fs, ax		; FS 세그먼트 셀렉터에 설정
	mov gs, ax		; GS 세그먼트 셀렉터에 설정
	
	; 스택을 0x00000000 ~ 0x0000FFFF 영역에 64KB 크기로 생성
	mov ss, ax		; SS 세그먼트 셀렉터에 설정
	mov esp, 0xFFFE
	mov ebp, 0xFFFE
```

디스크립터 크기가 8바이트이기 때문에 1번째(0x00), 2번째(0x08), 3번째(0x10) . . . 이런식으로 세그먼트 셀렉터에서 접근하면 됨.



> 그림 및 설명 등 자료: Intel® 64 and IA-32 Architectures Developer's Manual: Vol. 3A